# Phase 4: Integration & End-to-End Testing

## Overview
Comprehensive integration testing of the complete ObjectFactory â†’ CallLogger â†’ Parrot pipeline to ensure the object ID tracking system works seamlessly across all components.

## Current State Analysis
After Phases 1-3:
- ObjectFactory has object registry with ID tracking
- CallLogger formats registered objects as `<id:string_id>`
- Parrot parses and resolves object IDs from verified files
- Individual components tested in isolation

## Goals
1. Verify complete workflow from registration to replay
2. Test complex scenarios with multiple objects and interactions
3. Ensure thread safety across components
4. Validate error handling in realistic scenarios
5. Document usage patterns and best practices

---

## Tests to Implement First (TDD)

### Test File: `ObjectIdWorkflowIntegrationTests.cs`

#### 1. Basic End-to-End Workflow Tests
```csharp
[Fact]
public async Task FullWorkflow_RegisterLogReplay_ShouldWork()
[Fact]
public async Task FullWorkflow_WithMultipleServices_ShouldMaintainCorrectIds()
[Fact]
public async Task FullWorkflow_WithNestedServiceCalls_ShouldTrackAllObjects()
[Fact]
public async Task FullWorkflow_WithAutoGeneratedIds_ShouldWork()
```

#### 2. Complex Interaction Scenarios
```csharp
[Fact]
public async Task ComplexScenario_ServicePassingObjectsToOtherServices_ShouldWork()
[Fact]
public async Task ComplexScenario_ReturningRegisteredObjects_ShouldWork()
[Fact]
public async Task ComplexScenario_MixedPrimitivesAndObjects_ShouldWork()
[Fact]
public async Task ComplexScenario_CollectionsContainingRegisteredObjects_ShouldWork()
```

#### 3. Error Handling Integration Tests
```csharp
[Fact]
public async Task ErrorHandling_UnregisteredObjectInCallLogger_ShouldShowUnknown()
[Fact]
public async Task ErrorHandling_UnknownInVerifiedFile_ShouldFailParrot()
[Fact]
public async Task ErrorHandling_MissingIdInRegistry_ShouldFailParrot()
[Fact]
public async Task ErrorHandling_TypeMismatchOnResolvedObject_ShouldFailParrot()
```

#### 4. Thread Safety Integration Tests  
```csharp
[Fact]
public async Task ThreadSafety_ConcurrentRegistrationAndLogging_ShouldWork()
[Fact]
public async Task ThreadSafety_ConcurrentParrotReplay_ShouldWork()
[Fact]
public async Task ThreadSafety_RegistryChangesWhileLogging_ShouldBeConsistent()
```

#### 5. Legacy Compatibility Tests
```csharp
[Fact]
public async Task LegacyCompatibility_ExistingTestsWithoutIds_ShouldStillWork()
[Fact]
public async Task LegacyCompatibility_MixedIdAndNonIdObjects_ShouldWork()
[Fact]
public async Task LegacyCompatibility_ExistingVerifiedFiles_ShouldStillWork()
```

#### 6. Performance and Edge Cases
```csharp
[Fact]
public async Task Performance_LargeNumberOfRegisteredObjects_ShouldPerform()
[Fact]
public async Task EdgeCase_SameObjectMultipleIds_ShouldUseFirstId()
[Fact]
public async Task EdgeCase_ObjectRegisteredAfterFirstUse_ShouldShowUnknownThenId()
[Fact]
public async Task EdgeCase_ClearedRegistryDuringTest_ShouldHandleGracefully()
```

---

## Integration Test Scenarios

### Scenario 1: Basic Service Collaboration
```csharp
// Setup
var factory = new ObjectFactory();
var userService = new UserService();
var emailService = new EmailService();
factory.Register(userService, "userSvc");
factory.Register(emailService, "emailSvc");

// Test execution with CallLogger
var logger = new CallLogger(objectFactory: factory);
var wrappedUserService = logger.Wrap<IUserService>(userService, "ðŸ‘¤", factory);
var wrappedEmailService = logger.Wrap<IEmailService>(emailService, "ðŸ“§", factory);

// Execute business logic that calls between services
wrappedUserService.ProcessUser(user, wrappedEmailService);

// Verify log shows: <id:userSvc> and <id:emailSvc>
// Create Parrot and replay to ensure it works
```

### Scenario 2: Complex Object Passing
```csharp
// Services that pass objects to each other
// A calls B with object X, B calls C with same object X
// Verify all references to X use same ID
```

### Scenario 3: Object Return Values
```csharp
// Service returns registered objects
// Verify return values logged as IDs
// Parrot can replay and return correct object instances
```

### Scenario 4: Collection Handling
```csharp
// Arrays/Lists containing registered objects
// Verify collection format: [<id:obj1>, <id:obj2>, "primitive"]
// Parrot can parse and resolve mixed collections
```

---

## Implementation Plan

### Step 1: Create Integration Test Infrastructure
```csharp
// Test services that collaborate
public interface IUserService { void ProcessUser(User user, IEmailService emailService); }
public interface IEmailService { bool SendEmail(string to, string subject); }
public interface IDataService { User GetUser(string id); }

// Concrete implementations for testing
public class UserService : IUserService { /* implementation */ }
public class EmailService : IEmailService { /* implementation */ }
public class DataService : IDataService { /* implementation */ }

// Test data objects
public class User { public string Id { get; set; } public string Email { get; set; } }
```

### Step 2: Test Utilities and Helpers
```csharp
public static class IntegrationTestHelpers
{
    public static (ObjectFactory factory, CallLogger logger) SetupFactoryAndLogger()
    public static CallLog CreateAndRunWorkflow(ObjectFactory factory, Action<object> businessLogic)
    public static void VerifySpecContains(string spec, params string[] expectedIds)
    public static T CreateParrotAndReplay<T>(CallLog callLog, ObjectFactory factory) where T : class
}
```

### Step 3: Complex Workflow Test Patterns
```csharp
// Pattern: Register â†’ Execute â†’ Log â†’ Verify â†’ Replay
[Fact]
public async Task ComplexWorkflow_MultiServiceInteraction()
{
    // 1. Setup - register all objects with IDs
    var factory = new ObjectFactory();
    var services = SetupServices(factory);
    
    // 2. Execute - run business logic with wrapped services
    var logger = new CallLogger(objectFactory: factory);
    var wrappedServices = WrapServices(services, logger, factory);
    ExecuteBusinessLogic(wrappedServices);
    
    // 3. Verify - check log contains expected ID references
    var spec = logger.SpecBook.ToString();
    VerifySpecContains(spec, "userSvc", "emailSvc", "dataSvc");
    await Verify(spec);
    
    // 4. Replay - create Parrot and replay interactions
    var callLog = new CallLog(spec, factory);
    var parrotServices = CreateParrotServices(callLog, factory);
    ExecuteBusinessLogic(parrotServices); // Should work identically
}
```

### Step 4: Error Scenario Testing
```csharp
// Test various failure modes with helpful error messages
// Verify exceptions contain useful troubleshooting information
```

### Step 5: Performance Testing
```csharp
// Test with large numbers of registered objects
// Measure lookup performance
// Verify memory usage is reasonable
```

---

## Success Criteria Verification

### Functional Requirements
- [ ] Objects registered with ObjectFactory appear as `<id:string_id>` in logs
- [ ] Unregistered objects appear as `<unknown>` in logs  
- [ ] Parrot successfully resolves `<id:string_id>` to correct object instances
- [ ] Parrot throws helpful errors for `<unknown>` and missing IDs
- [ ] Collections containing objects are handled correctly
- [ ] Thread safety maintained across all components

### Quality Requirements
- [ ] All integration tests pass
- [ ] Existing SpecRec tests still pass (no regressions)
- [ ] Error messages are helpful for debugging
- [ ] Performance is acceptable for typical usage
- [ ] Code is maintainable and well-documented

### Documentation Requirements
- [ ] Usage examples for common scenarios
- [ ] Best practices guide
- [ ] Migration guide for existing tests
- [ ] API documentation updates

---

## Test Organization

### Test File Structure
```
SpecRec.Tests/
â”œâ”€â”€ ObjectFactoryIdTests.cs           # Phase 1
â”œâ”€â”€ CallLoggerIdFormattingTests.cs    # Phase 2  
â”œâ”€â”€ ParrotObjectIdTests.cs            # Phase 3
â”œâ”€â”€ ObjectIdWorkflowIntegrationTests.cs # Phase 4
â””â”€â”€ fixtures/
    â”œâ”€â”€ integration-scenarios/
    â”‚   â”œâ”€â”€ BasicServiceCollaboration.verified.txt
    â”‚   â”œâ”€â”€ ComplexObjectPassing.verified.txt
    â”‚   â””â”€â”€ CollectionHandling.verified.txt
    â””â”€â”€ test-services/
        â”œâ”€â”€ UserService.cs
        â”œâ”€â”€ EmailService.cs
        â””â”€â”€ DataService.cs
```

### Test Verification Strategy

1. **Write comprehensive failing tests** covering all scenarios
2. **Run Phases 1-3 implementations** to get basic functionality working
3. **Implement integration scenarios** one by one
4. **Verify no regressions** by running full test suite
5. **Performance testing** with realistic loads
6. **Documentation and examples** based on working integration tests

## Expected Test Failures
Before full integration:
- Object ID resolution across component boundaries
- Complex object passing scenarios
- Error handling edge cases
- Thread safety in multi-component scenarios

## Deliverables
- Complete integration test suite
- Working end-to-end object ID tracking
- Updated documentation and examples
- Performance baseline measurements
- Best practices guide